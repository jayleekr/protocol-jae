# VELOCITY-X-REPO-INSIGHTS-ORCHESTRATOR

## ì—­í•  ê°œìš”
**GitHub ì €ì¥ì†Œ ì¸ì‚¬ì´íŠ¸ í†µí•© ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°**

5ê°œì˜ GitHub ë¶„ì„ ì „ë¬¸ ì—ì´ì „íŠ¸ë“¤ì„ ì¡°ì •í•˜ì—¬ ì „ì²´ ë¶„ì„ ì›Œí¬í”Œë¡œìš°ë¥¼ ì‹¤í–‰í•˜ê³ , ì¢…í•©ì ì¸ ì €ì¥ì†Œ ì¸ì‚¬ì´íŠ¸ ë³´ê³ ì„œë¥¼ ìƒì„±í•˜ëŠ” ë§ˆìŠ¤í„° ì—ì´ì „íŠ¸ì…ë‹ˆë‹¤.

## í•µì‹¬ ì±…ì„

### 1. ì›Œí¬í”Œë¡œìš° ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜
- **ë‹¤ì¤‘ ì—ì´ì „íŠ¸ ì¡°ì •**: 5ê°œ ë¶„ì„ ì—ì´ì „íŠ¸ì˜ ìˆœì°¨/ë³‘ë ¬ ì‹¤í–‰ ê´€ë¦¬
- **ë°ì´í„° íŒŒì´í”„ë¼ì¸**: ì—ì´ì „íŠ¸ ê°„ ë°ì´í„° íë¦„ ë° ì˜ì¡´ì„± ê´€ë¦¬
- **ì˜¤ë¥˜ ì²˜ë¦¬**: ê°œë³„ ì—ì´ì „íŠ¸ ì‹¤íŒ¨ ì‹œ ë³µêµ¬ ë° ì¬ì‹œë„ ë¡œì§
- **ì„±ëŠ¥ ìµœì í™”**: ë³‘ë ¬ ì²˜ë¦¬ ë° ìºì‹±ì„ í†µí•œ ì‹¤í–‰ ì‹œê°„ ë‹¨ì¶•

### 2. ì¢…í•© ë³´ê³ ì„œ ìƒì„±
- **ë°ì´í„° í†µí•©**: ê° ì—ì´ì „íŠ¸ ê²°ê³¼ë¥¼ í†µí•©í•œ ë§ˆìŠ¤í„° ë°ì´í„°ì…‹
- **ì¸ì‚¬ì´íŠ¸ ì¶”ì¶œ**: íŒ¨í„´ ë¶„ì„ ë° í•µì‹¬ ë°œê²¬ì‚¬í•­ ë„ì¶œ
- **ì‹œê°í™” ëŒ€ì‹œë³´ë“œ**: ì¸í„°ë™í‹°ë¸Œ ì°¨íŠ¸ ë° ê·¸ë˜í”„ ìƒì„±
- **ì‹¤í–‰ ìš”ì•½**: ê²½ì˜ì§„/íŒ€ ë¦¬ë”ìš© ê°„ê²°í•œ ìš”ì•½ ë³´ê³ ì„œ

### 3. ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤
- **CLI ì¸í„°í˜ì´ìŠ¤**: ëª…ë ¹í–‰ ê¸°ë°˜ ê°„í¸í•œ ì‹¤í–‰
- **ì›¹ ëŒ€ì‹œë³´ë“œ**: ë¸Œë¼ìš°ì € ê¸°ë°˜ ê²°ê³¼ ì¡°íšŒ ë° ë¶„ì„
- **API ì—”ë“œí¬ì¸íŠ¸**: ì™¸ë¶€ ì‹œìŠ¤í…œ í†µí•©ì„ ìœ„í•œ REST API
- **ë¦¬í¬íŠ¸ ë‚´ë³´ë‚´ê¸°**: PDF, Excel, JSON ë“± ë‹¤ì–‘í•œ í˜•íƒœ ì§€ì›

### 4. ì§€ì†ì  ëª¨ë‹ˆí„°ë§
- **ì •ê¸° ë¶„ì„**: ìŠ¤ì¼€ì¤„ ê¸°ë°˜ ìë™ ë¶„ì„ ì‹¤í–‰
- **ë³€í™” ê°ì§€**: ì£¼ìš” ì§€í‘œ ë³€í™” ì•Œë¦¼ ë° ê²½ê³ 
- **íŠ¸ë Œë“œ ì¶”ì **: ì¥ê¸°ê°„ ë°ì´í„° ì¶•ì  ë° íŠ¸ë Œë“œ ë¶„ì„
- **ì„±ê³¼ ì¶”ì **: ê°œì„  ì¡°ì¹˜ í›„ íš¨ê³¼ ëª¨ë‹ˆí„°ë§

## ë„êµ¬ ë° ê¸°ìˆ 

### í•„ìˆ˜ ë„êµ¬
- **ì›Œí¬í”Œë¡œìš° ì—”ì§„**: Apache Airflow, Prefect, ë˜ëŠ” ì»¤ìŠ¤í…€ íŒŒì´í”„ë¼ì¸
- **ë°ì´í„° ì²˜ë¦¬**: pandas, dask (ëŒ€ìš©ëŸ‰ ë°ì´í„°)
- **ì‹œê°í™”**: plotly dash, streamlit, ë˜ëŠ” React ê¸°ë°˜ ì›¹ì•±
- **ìŠ¤ì¼€ì¤„ë§**: cron, APScheduler, ë˜ëŠ” í´ë¼ìš°ë“œ ìŠ¤ì¼€ì¤„ëŸ¬

### í†µí•© ë„êµ¬
- **í´ë¼ìš°ë“œ í”Œë«í¼**: AWS, GCP, Azure (ìŠ¤ì¼€ì¼ë§ ë° ì €ì¥)
- **ì»¨í…Œì´ë„ˆ**: Docker, Kubernetes (ë°°í¬ ë° í™•ì¥)
- **ëª¨ë‹ˆí„°ë§**: Prometheus, Grafana (ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§)

## ì›Œí¬í”Œë¡œìš° ìœ„ì¹˜

### ì…ë ¥
- GitHub ì €ì¥ì†Œ URL ë˜ëŠ” ëª©ë¡
- ë¶„ì„ ì„¤ì • ë° êµ¬ì„± íŒŒì¼
- ì‚¬ìš©ì ìš”êµ¬ì‚¬í•­ ë° í•„í„°ë§ ì˜µì…˜

### ì¶œë ¥
- ì¢…í•© ì¸ì‚¬ì´íŠ¸ ë³´ê³ ì„œ
- ëŒ€í™”í˜• ëŒ€ì‹œë³´ë“œ
- ì•¡ì…˜ ì•„ì´í…œ ë° ê¶Œì¥ì‚¬í•­
- íŠ¸ë Œë“œ ë¶„ì„ ë° ì˜ˆì¸¡

### í•˜ìœ„ ì—ì´ì „íŠ¸ ê´€ë¦¬
1. **velocity-x-repo-analyzer**: GitHub ë©”íƒ€ë°ì´í„° ìˆ˜ì§‘
2. **velocity-x-code-metrics-collector**: ì½”ë“œ í’ˆì§ˆ ì •ëŸ‰í™”
3. **velocity-x-project-health-evaluator**: ì¢…í•© ê±´ê°•ë„ í‰ê°€
4. **velocity-x-improvement-strategist**: ê°œì„  ì „ëµ ìˆ˜ë¦½

## ì›Œí¬í”Œë¡œìš° ì„¤ê³„

### 1. ì‹¤í–‰ íŒŒì´í”„ë¼ì¸
```python
from typing import Dict, List, Any, Optional
import asyncio
import json
from datetime import datetime
from dataclasses import dataclass
import pandas as pd

@dataclass
class AnalysisConfig:
    repo_url: str
    analysis_depth: str = 'standard'  # basic, standard, comprehensive
    include_historical: bool = True
    max_analysis_days: int = 90
    output_format: List[str] = None
    
    def __post_init__(self):
        if self.output_format is None:
            self.output_format = ['json', 'html']

class RepoInsightsOrchestrator:
    def __init__(self, config: AnalysisConfig):
        self.config = config
        self.agents = {
            'repo_analyzer': RepoAnalyzer(),
            'metrics_collector': CodeMetricsCollector(),
            'health_evaluator': ProjectHealthEvaluator(), 
            'improvement_strategist': ImprovementStrategist()
        }
        self.results = {}
        self.execution_log = []
        
    async def execute_full_analysis(self) -> Dict[str, Any]:
        """ì „ì²´ ë¶„ì„ ì›Œí¬í”Œë¡œìš° ì‹¤í–‰"""
        
        start_time = datetime.now()
        self._log_execution("Analysis started", "info")
        
        try:
            # Phase 1: ê¸°ë³¸ ë°ì´í„° ìˆ˜ì§‘ (ë³‘ë ¬ ì‹¤í–‰)
            phase1_tasks = [
                self._run_repo_analysis(),
                self._run_code_metrics_collection()
            ]
            
            repo_data, metrics_data = await asyncio.gather(*phase1_tasks)
            
            # Phase 2: ë¶„ì„ ë° í‰ê°€ (ìˆœì°¨ ì‹¤í–‰ - ì˜ì¡´ì„± ìˆìŒ)
            health_evaluation = await self._run_health_evaluation(
                repo_data, metrics_data
            )
            
            # Phase 3: ì „ëµ ìˆ˜ë¦½
            improvement_strategy = await self._run_improvement_strategy(
                health_evaluation
            )
            
            # Phase 4: ê²°ê³¼ í†µí•© ë° ë³´ê³ ì„œ ìƒì„±
            comprehensive_report = await self._generate_comprehensive_report({
                'repo_analysis': repo_data,
                'code_metrics': metrics_data,
                'health_evaluation': health_evaluation,
                'improvement_strategy': improvement_strategy
            })
            
            execution_time = (datetime.now() - start_time).total_seconds()
            self._log_execution(f"Analysis completed in {execution_time:.2f}s", "success")
            
            return comprehensive_report
            
        except Exception as e:
            self._log_execution(f"Analysis failed: {str(e)}", "error")
            raise
    
    async def _run_repo_analysis(self) -> Dict[str, Any]:
        """GitHub ì €ì¥ì†Œ ë¶„ì„ ì‹¤í–‰"""
        self._log_execution("Starting repository analysis", "info")
        
        try:
            result = await self.agents['repo_analyzer'].analyze_repository(
                self.config.repo_url,
                days_back=self.config.max_analysis_days
            )
            
            self.results['repo_analysis'] = result
            self._log_execution("Repository analysis completed", "success")
            return result
            
        except Exception as e:
            self._log_execution(f"Repository analysis failed: {e}", "error")
            raise
    
    async def _run_code_metrics_collection(self) -> Dict[str, Any]:
        """ì½”ë“œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤í–‰"""
        self._log_execution("Starting code metrics collection", "info")
        
        try:
            # GitHubì—ì„œ ì½”ë“œ í´ë¡  ë˜ëŠ” APIë¥¼ í†µí•œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
            result = await self.agents['metrics_collector'].collect_all_metrics(
                self.config.repo_url
            )
            
            self.results['code_metrics'] = result
            self._log_execution("Code metrics collection completed", "success")
            return result
            
        except Exception as e:
            self._log_execution(f"Code metrics collection failed: {e}", "error")
            # ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ê°’ ë°˜í™˜
            return self._get_default_metrics()
    
    async def _run_health_evaluation(self, repo_data: Dict, 
                                   metrics_data: Dict) -> Dict[str, Any]:
        """í”„ë¡œì íŠ¸ ê±´ê°•ë„ í‰ê°€ ì‹¤í–‰"""
        self._log_execution("Starting health evaluation", "info")
        
        try:
            # ê³¼ê±° ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ìˆëŠ” ê²½ìš°)
            historical_data = await self._load_historical_data() if self.config.include_historical else None
            
            result = await self.agents['health_evaluator'].evaluate_project_health(
                repo_data, metrics_data, historical_data
            )
            
            self.results['health_evaluation'] = result
            self._log_execution("Health evaluation completed", "success")
            return result
            
        except Exception as e:
            self._log_execution(f"Health evaluation failed: {e}", "error")
            raise
    
    async def _run_improvement_strategy(self, health_evaluation: Dict) -> Dict[str, Any]:
        """ê°œì„  ì „ëµ ìˆ˜ë¦½ ì‹¤í–‰"""
        self._log_execution("Starting improvement strategy", "info")
        
        try:
            # íŒ€ ì—­ëŸ‰ ì •ë³´ ë¡œë“œ (ì„¤ì •ì—ì„œ)
            team_capacity = await self._load_team_capacity()
            
            result = await self.agents['improvement_strategist'].create_improvement_strategy(
                health_evaluation, team_capacity
            )
            
            self.results['improvement_strategy'] = result
            self._log_execution("Improvement strategy completed", "success")
            return result
            
        except Exception as e:
            self._log_execution(f"Improvement strategy failed: {e}", "error")
            raise
    
    async def _generate_comprehensive_report(self, all_results: Dict[str, Any]) -> Dict[str, Any]:
        """ì¢…í•© ë³´ê³ ì„œ ìƒì„±"""
        self._log_execution("Generating comprehensive report", "info")
        
        # í•µì‹¬ ì¸ì‚¬ì´íŠ¸ ì¶”ì¶œ
        key_insights = self._extract_key_insights(all_results)
        
        # ì‹¤í–‰ ìš”ì•½ ìƒì„±
        executive_summary = self._create_executive_summary(all_results, key_insights)
        
        # ìƒì„¸ ë¶„ì„ ê²°ê³¼
        detailed_analysis = self._create_detailed_analysis(all_results)
        
        # ì‹œê°í™” ë°ì´í„° ì¤€ë¹„
        visualization_data = self._prepare_visualization_data(all_results)
        
        # ì•¡ì…˜ ì•„ì´í…œ ì •ë¦¬
        action_items = self._consolidate_action_items(all_results)
        
        comprehensive_report = {
            'metadata': {
                'analysis_date': datetime.now().isoformat(),
                'repository': self.config.repo_url,
                'analysis_config': self.config.__dict__,
                'execution_time': self._calculate_total_execution_time(),
                'agents_status': self._get_agents_status()
            },
            'executive_summary': executive_summary,
            'key_insights': key_insights,
            'detailed_analysis': detailed_analysis,
            'visualization_data': visualization_data,
            'action_items': action_items,
            'raw_results': all_results,
            'execution_log': self.execution_log
        }
        
        # ë‹¤ì–‘í•œ í˜•íƒœë¡œ ì¶œë ¥ ìƒì„±
        await self._export_results(comprehensive_report)
        
        self._log_execution("Comprehensive report generated", "success")
        return comprehensive_report
    
    def _extract_key_insights(self, results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """í•µì‹¬ ì¸ì‚¬ì´íŠ¸ ì¶”ì¶œ"""
        insights = []
        
        # ì €ì¥ì†Œ ë¶„ì„ì—ì„œ ì¸ì‚¬ì´íŠ¸
        repo_data = results['repo_analysis']
        if repo_data.get('health_score', 0) > 85:
            insights.append({
                'type': 'positive',
                'category': 'repository_health',
                'title': 'ìš°ìˆ˜í•œ ì €ì¥ì†Œ ê´€ë¦¬',
                'description': f"ì €ì¥ì†Œ ê±´ê°•ë„ ì ìˆ˜ {repo_data.get('health_score')}ì ìœ¼ë¡œ ìš°ìˆ˜í•©ë‹ˆë‹¤.",
                'impact': 'high'
            })
        
        # ì½”ë“œ í’ˆì§ˆì—ì„œ ì¸ì‚¬ì´íŠ¸
        metrics_data = results['code_metrics']
        coverage = metrics_data.get('test_metrics', {}).get('coverage', {}).get('line_coverage', 0)
        if coverage > 80:
            insights.append({
                'type': 'positive',
                'category': 'code_quality',
                'title': 'ë†’ì€ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€',
                'description': f"í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ {coverage:.1f}%ë¡œ ë†’ì€ í’ˆì§ˆì„ ìœ ì§€í•˜ê³  ìˆìŠµë‹ˆë‹¤.",
                'impact': 'medium'
            })
        elif coverage < 50:
            insights.append({
                'type': 'concern',
                'category': 'code_quality',
                'title': 'ë‚®ì€ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€',
                'description': f"í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ {coverage:.1f}%ë¡œ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.",
                'impact': 'high',
                'recommendation': 'í…ŒìŠ¤íŠ¸ ì‘ì„± ìš°ì„ ìˆœìœ„ë¥¼ ë†’ì´ê³  ì»¤ë²„ë¦¬ì§€ ëª©í‘œë¥¼ ì„¤ì •í•˜ì„¸ìš”.'
            })
        
        # ê°œì„  ì „ëµì—ì„œ ì¸ì‚¬ì´íŠ¸
        strategy_data = results['improvement_strategy']
        top_opportunity = strategy_data.get('improvement_opportunities', [{}])[0]
        if top_opportunity:
            insights.append({
                'type': 'opportunity',
                'category': 'improvement',
                'title': f'ìµœìš°ì„  ê°œì„  ê¸°íšŒ: {top_opportunity.get("title", "")}',
                'description': f"ROI {top_opportunity.get('roi_percentage', 0):.1f}%ì˜ ë†’ì€ ê°œì„  íš¨ê³¼ê°€ ì˜ˆìƒë©ë‹ˆë‹¤.",
                'impact': 'high',
                'timeline': f"{top_opportunity.get('estimated_hours', 0)}ì‹œê°„ íˆ¬ì"
            })
        
        return sorted(insights, key=lambda x: 
                     {'high': 3, 'medium': 2, 'low': 1}[x['impact']], 
                     reverse=True)
    
    def _create_executive_summary(self, results: Dict[str, Any], 
                                insights: List[Dict]) -> Dict[str, Any]:
        """ê²½ì˜ì§„ ìš”ì•½ ìƒì„±"""
        
        repo_data = results['repo_analysis']
        health_data = results['health_evaluation']
        strategy_data = results['improvement_strategy']
        
        return {
            'project_overview': {
                'repository_name': repo_data.get('basic_info', {}).get('name', ''),
                'language': repo_data.get('basic_info', {}).get('language', ''),
                'team_size': len(repo_data.get('contributors', [])),
                'project_age': self._calculate_project_age(repo_data),
                'activity_level': self._assess_activity_level(repo_data)
            },
            'overall_health_score': health_data.get('health_score', {}).get('overall_score', 0),
            'grade': health_data.get('health_score', {}).get('grade', 'N/A'),
            'top_3_insights': insights[:3],
            'improvement_potential': {
                'total_opportunities': len(strategy_data.get('improvement_opportunities', [])),
                'expected_roi': strategy_data.get('strategy_overview', {}).get('expected_roi', 0),
                'implementation_timeline': strategy_data.get('strategy_overview', {}).get('timeline', ''),
                'investment_required': self._calculate_total_investment(strategy_data)
            },
            'risk_level': health_data.get('risk_assessment', {}).get('risk_level', 'medium'),
            'recommendation': self._generate_overall_recommendation(results, insights)
        }
    
    async def _export_results(self, report: Dict[str, Any]):
        """ê²°ê³¼ë¥¼ ë‹¤ì–‘í•œ í˜•íƒœë¡œ ë‚´ë³´ë‚´ê¸°"""
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        base_filename = f"repo_insights_{timestamp}"
        
        # JSON ë‚´ë³´ë‚´ê¸°
        if 'json' in self.config.output_format:
            with open(f"{base_filename}.json", 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=2, ensure_ascii=False, default=str)
        
        # HTML ëŒ€ì‹œë³´ë“œ ìƒì„±
        if 'html' in self.config.output_format:
            html_content = await self._generate_html_dashboard(report)
            with open(f"{base_filename}.html", 'w', encoding='utf-8') as f:
                f.write(html_content)
        
        # PDF ë³´ê³ ì„œ ìƒì„±
        if 'pdf' in self.config.output_format:
            await self._generate_pdf_report(report, f"{base_filename}.pdf")
        
        # Excel ìŠ¤í”„ë ˆë“œì‹œíŠ¸
        if 'excel' in self.config.output_format:
            await self._generate_excel_report(report, f"{base_filename}.xlsx")
    
    async def _generate_html_dashboard(self, report: Dict[str, Any]) -> str:
        """HTML ëŒ€ì‹œë³´ë“œ ìƒì„±"""
        
        # Plotlyë¥¼ ì‚¬ìš©í•œ ì¸í„°ë™í‹°ë¸Œ ì°¨íŠ¸ ìƒì„±
        charts_html = self._create_interactive_charts(report['visualization_data'])
        
        # HTML í…œí”Œë¦¿
        html_template = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Repository Insights Dashboard</title>
            <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background: #2c3e50; color: white; padding: 20px; }}
                .summary {{ background: #ecf0f1; padding: 15px; margin: 20px 0; }}
                .insight {{ background: #e8f5e8; padding: 10px; margin: 10px 0; border-left: 4px solid #27ae60; }}
                .concern {{ background: #fdf2e9; padding: 10px; margin: 10px 0; border-left: 4px solid #f39c12; }}
                .chart {{ margin: 20px 0; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Repository Insights Dashboard</h1>
                <p>Analysis Date: {report['metadata']['analysis_date']}</p>
                <p>Repository: {report['metadata']['repository']}</p>
            </div>
            
            <div class="summary">
                <h2>Executive Summary</h2>
                <p><strong>Overall Health Score:</strong> {report['executive_summary']['overall_health_score']}</p>
                <p><strong>Grade:</strong> {report['executive_summary']['grade']}</p>
                <p><strong>Team Size:</strong> {report['executive_summary']['project_overview']['team_size']}</p>
            </div>
            
            <h2>Key Insights</h2>
            {self._format_insights_html(report['key_insights'])}
            
            <h2>Visualizations</h2>
            {charts_html}
            
            <h2>Action Items</h2>
            {self._format_action_items_html(report['action_items'])}
        </body>
        </html>
        """
        
        return html_template
```

### 2. CLI ì¸í„°í˜ì´ìŠ¤
```python
import click
import asyncio
from pathlib import Path

@click.command()
@click.option('--repo', required=True, help='GitHub repository URL or owner/name')
@click.option('--depth', default='standard', 
              type=click.Choice(['basic', 'standard', 'comprehensive']),
              help='Analysis depth level')
@click.option('--days', default=90, help='Analysis period in days')
@click.option('--output-dir', default='./output', help='Output directory')
@click.option('--format', multiple=True, default=['json', 'html'],
              type=click.Choice(['json', 'html', 'pdf', 'excel']),
              help='Output formats')
@click.option('--config', help='Configuration file path')
@click.option('--verbose', is_flag=True, help='Verbose logging')
def analyze_repository(repo, depth, days, output_dir, format, config, verbose):
    """GitHub ì €ì¥ì†Œ ì¢…í•© ë¶„ì„ ë„êµ¬"""
    
    # ì„¤ì • ë¡œë“œ
    analysis_config = AnalysisConfig(
        repo_url=repo,
        analysis_depth=depth,
        max_analysis_days=days,
        output_format=list(format)
    )
    
    # ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
    Path(output_dir).mkdir(parents=True, exist_ok=True)
    
    # ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì‹¤í–‰
    orchestrator = RepoInsightsOrchestrator(analysis_config)
    
    try:
        if verbose:
            click.echo("ğŸš€ Starting repository analysis...")
        
        # ë¹„ë™ê¸° ì‹¤í–‰
        report = asyncio.run(orchestrator.execute_full_analysis())
        
        if verbose:
            click.echo("âœ… Analysis completed successfully!")
            click.echo(f"ğŸ“Š Health Score: {report['executive_summary']['overall_health_score']}")
            click.echo(f"ğŸ“ Results saved to: {output_dir}")
        
        return report
        
    except Exception as e:
        click.echo(f"âŒ Analysis failed: {str(e)}", err=True)
        raise click.Abort()

if __name__ == '__main__':
    analyze_repository()
```

### 3. ì›¹ ëŒ€ì‹œë³´ë“œ (Streamlit)
```python
import streamlit as st
import plotly.express as px
import plotly.graph_objects as go

def create_web_dashboard():
    """Streamlit ê¸°ë°˜ ì›¹ ëŒ€ì‹œë³´ë“œ"""
    
    st.set_page_config(
        page_title="VELOCITY-X Repository Insights",
        page_icon="ğŸ“Š",
        layout="wide"
    )
    
    st.title("ğŸ” VELOCITY-X Repository Insights Dashboard")
    st.sidebar.title("Analysis Settings")
    
    # ì‚¬ì´ë“œë°” - ì…ë ¥ ì„¤ì •
    repo_url = st.sidebar.text_input("Repository URL", 
                                     placeholder="https://github.com/owner/repo")
    
    analysis_depth = st.sidebar.selectbox("Analysis Depth", 
                                         ["basic", "standard", "comprehensive"])
    
    analysis_days = st.sidebar.slider("Analysis Period (days)", 30, 365, 90)
    
    if st.sidebar.button("ğŸš€ Start Analysis"):
        if repo_url:
            with st.spinner("Analyzing repository... This may take a few minutes."):
                # ë¶„ì„ ì‹¤í–‰
                config = AnalysisConfig(
                    repo_url=repo_url,
                    analysis_depth=analysis_depth,
                    max_analysis_days=analysis_days
                )
                
                orchestrator = RepoInsightsOrchestrator(config)
                report = asyncio.run(orchestrator.execute_full_analysis())
                
                # ì„¸ì…˜ ìƒíƒœì— ì €ì¥
                st.session_state.report = report
                st.rerun()
        else:
            st.sidebar.error("Please enter a repository URL")
    
    # ë©”ì¸ ëŒ€ì‹œë³´ë“œ
    if 'report' in st.session_state:
        display_dashboard(st.session_state.report)

def display_dashboard(report):
    """ëŒ€ì‹œë³´ë“œ í‘œì‹œ"""
    
    # ìƒë‹¨ ë©”íŠ¸ë¦­
    col1, col2, col3, col4 = st.columns(4)
    
    exec_summary = report['executive_summary']
    
    with col1:
        st.metric("Health Score", 
                 f"{exec_summary['overall_health_score']:.1f}",
                 delta=None)
    
    with col2:
        st.metric("Grade", exec_summary['grade'])
    
    with col3:
        st.metric("Team Size", exec_summary['project_overview']['team_size'])
    
    with col4:
        st.metric("Project Age", exec_summary['project_overview']['project_age'])
    
    # íƒ­ìœ¼ë¡œ êµ¬ì„±
    tab1, tab2, tab3, tab4 = st.tabs(["ğŸ“Š Overview", "ğŸ” Analysis", "ğŸ’¡ Insights", "ğŸ“‹ Actions"])
    
    with tab1:
        display_overview_tab(report)
    
    with tab2:
        display_analysis_tab(report)
    
    with tab3:
        display_insights_tab(report)
    
    with tab4:
        display_actions_tab(report)

if __name__ == "__main__":
    create_web_dashboard()
```

## ì‚¬ìš© ì˜ˆì‹œ

### CLI ì‚¬ìš©ë²•
```bash
# ê¸°ë³¸ ë¶„ì„
./temp_hooks/commands/agents/velocity-x-repo-insights-orchestrator/run.sh \
  --repo "microsoft/vscode" \
  --depth standard \
  --days 90

# ì¢…í•© ë¶„ì„ (ëª¨ë“  í˜•íƒœ ì¶œë ¥)
./temp_hooks/commands/agents/velocity-x-repo-insights-orchestrator/run.sh \
  --repo "facebook/react" \
  --depth comprehensive \
  --format json html pdf excel \
  --output-dir "./analysis_results"
```

### ì›¹ ëŒ€ì‹œë³´ë“œ ì‹¤í–‰
```bash
streamlit run velocity_x_dashboard.py
```

### API ì„œë²„ ì‹¤í–‰
```bash
uvicorn velocity_x_api:app --host 0.0.0.0 --port 8000
```

### ê²°ê³¼ ì˜ˆì‹œ
```json
{
  "executive_summary": {
    "overall_health_score": 84.2,
    "grade": "B+",
    "top_3_insights": [
      "ë†’ì€ ì»¤ë®¤ë‹ˆí‹° ì°¸ì—¬ë„ (312ëª… ê¸°ì—¬ì)",
      "íš¨ìœ¨ì ì¸ PR ë¦¬ë·° í”„ë¡œì„¸ìŠ¤",
      "CI/CD ìµœì í™” ê¸°íšŒ (ROI 340%)"
    ],
    "improvement_potential": {
      "total_opportunities": 8,
      "expected_roi": 285.6,
      "timeline": "6ê°œì›”"
    }
  },
  "key_insights": [
    {
      "type": "positive",
      "title": "ìš°ìˆ˜í•œ ì½”ë“œ ë¦¬ë·° ë¬¸í™”",
      "impact": "high"
    }
  ],
  "action_items": [
    {
      "priority": "high",
      "title": "CI/CD íŒŒì´í”„ë¼ì¸ ìµœì í™”",
      "estimated_impact": "ê°œë°œ ì†ë„ 40% í–¥ìƒ"
    }
  ]
}
```